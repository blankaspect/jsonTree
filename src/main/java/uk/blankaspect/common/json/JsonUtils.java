/*====================================================================*\

JsonUtils.java

Class: JSON-related utility methods.

\*====================================================================*/


// PACKAGE


package uk.blankaspect.common.json;

//----------------------------------------------------------------------


// IMPORTS


import java.io.IOException;

import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;

import uk.blankaspect.common.basictree.AbstractNode;

//----------------------------------------------------------------------


// CLASS: JSON-RELATED UTILITY METHODS


/**
 * This class contains utility methods that relate to JSON.
 */

public class JsonUtils
{

////////////////////////////////////////////////////////////////////////
//  Constants
////////////////////////////////////////////////////////////////////////

	/** The name of the UTF-8 character encoding in the JDK. */
	private static final	String	ENCODING_NAME_UTF8	= "UTF-8";

	/** The string that is prefixed to the name of a temporary file. */
	private static final	String	TEMP_FILE_PREFIX	= "_$_";

////////////////////////////////////////////////////////////////////////
//  Constructors
////////////////////////////////////////////////////////////////////////

	/**
	 * Prevents this class from being instantiated externally.
	 */

	private JsonUtils()
	{
	}

	//------------------------------------------------------------------

////////////////////////////////////////////////////////////////////////
//  Class methods
////////////////////////////////////////////////////////////////////////

	/**
	 * Reads the specified file, parses its content as JSON text and returns the resulting JSON value.
	 *
	 * @param  file
	 *           the file that will be read and parsed as JSON text.
	 * @return the JSON value that results from parsing the content of <i>file</i>, if the file contains valid JSON
	 *         text.
	 * @throws IOException
	 *           if an error occurred when reading the file.
	 * @throws JsonParser.ParseException
	 *           if an error occurred when parsing the content of the file.
	 */

	public static AbstractNode readFile(Path file)
		throws IOException, JsonParser.ParseException
	{
		// Read the file; parse its content as JSON text and return the resulting JSON value
		return new JsonParser().parse(readText(file));
	}

	//------------------------------------------------------------------

	/**
	 * Reads the specified file and returns the resulting text, which is assumed to have the UTF-8 character encoding.
	 *
	 * @param  file
	 *           the file that will be read.
	 * @return the text content of <i>file</i>.
	 * @throws IOException
	 *           if an error occurred when reading the file.
	 */

	public static String readText(Path file)
		throws IOException
	{
		// Read the file; convert its content to text and return the text
		return new String(Files.readAllBytes(file), ENCODING_NAME_UTF8);
	}

	//------------------------------------------------------------------

	/**
	 * Writes the specified JSON value to the specified file as JSON text.  The text is generated by a new instance of
	 * {@link JsonGenerator} that has default values for the mode, the <i>opening bracket on the same line</i> flag,
	 * the indent increment and the maximum line length.  The file is written to a new file in the parent directory of
	 * the specified file, and the new file is then renamed to the specified file.
	 *
	 * @param  file
	 *           the file to which the JSON text of <i>value</i> will be written.
	 * @param  value
	 *           the JSON value whose JSON text will be written to <i>file</i>.
	 * @throws IOException
	 *           if an error occurred when writing the file.
	 */

	public static void writeFile(Path         file,
								 AbstractNode value)
		throws IOException
	{
		writeFile(file, value, new JsonGenerator());
	}

	//------------------------------------------------------------------

	/**
	 * Writes the specified JSON value to the specified file as JSON text that is generated by the specified instance of
	 * {@link JsonGenerator}.  The file is written to a new file in the parent directory of the specified file, and the
	 * new file is then renamed to the specified file.
	 *
	 * @param  file
	 *           the file to which the JSON text of <i>value</i> will be written.
	 * @param  value
	 *           the JSON value whose JSON text will be written to <i>file</i>.
	 * @param  generator
	 *           the object that will generate the JSON text for <i>value</i>.
	 * @throws IOException
	 *           if an error occurred when writing the file.
	 */

	public static void writeFile(Path          file,
								 AbstractNode  value,
								 JsonGenerator generator)
		throws IOException
	{
		// Convert the JSON value to text; write the text to the file
		writeText(file, generator.generate(value));
	}

	//------------------------------------------------------------------

	/**
	 * Writes the specified text to the specified file with the UTF-8 character encoding.  The file is written to a
	 * new file in the parent directory of the specified file, and the new file is then renamed to the specified file.
	 *
	 * @param  file
	 *           the file to which <i>text</i> will be written.
	 * @param  text
	 *           the text that will be written to <i>file</i>.
	 * @throws IOException
	 *           if an error occurred when writing the file.
	 */

	public static void writeText(Path   file,
								 String text)
		throws IOException
	{
		Path tempFile = null;
		try
		{
			// Create the parent directories of the output file
			Path parent = file.toAbsolutePath().getParent();
			if (parent != null)
				Files.createDirectories(parent);

			// Create a temporary file in the parent directory of the output file
			tempFile = Files.createTempFile(parent, TEMP_FILE_PREFIX, null);

			// Write the text to the temporary file
			Files.write(tempFile, text.getBytes(ENCODING_NAME_UTF8));

			// Rename the temporary file to the output file
			Files.move(tempFile, file, StandardCopyOption.REPLACE_EXISTING);

			// Invalidate the temporary file
			tempFile = null;
		}
		finally
		{
			// Delete the temporary file
			if ((tempFile != null) && Files.exists(tempFile))
				Files.delete(tempFile);
		}
	}

	//------------------------------------------------------------------

}

//----------------------------------------------------------------------
